#version 450

struct SlimeAgent
{
    vec2 pos;
    vec2 direction;
};

layout(std140, binding = 0) buffer agentBlock
{
    SlimeAgent agents[ ];
};

layout(binding = 1) uniform UBO
{
    float elapsedTime;
    float time;
    uint spaceWidth;
    uint spaceHeight;
    uint agentCount;
} ubo;

layout (binding = 2, rgba8) uniform image2D image;

uint hash(uint value) {
    value ^= 2747636419u;
    value *= 2654435769u;
    value ^= value >> 16;
    value *= 2654435769u;
    value ^= value >> 16;
    value *= 2654435769u;
    return value;
}
float scaleToRange01(uint state)
{
    return state / 4294967295.0;
}
#define PI 3.1415926538

layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;
void main()
{
    // 1D workload
    uint index = gl_GlobalInvocationID.x;
    if (index >= ubo.agentCount) {
        return;
    }

    float speedFactor = 200.0;

    vec2 cPos = agents[index].pos;
    vec2 cDir = agents[index].direction;

    vec2 nPos = agents[index].pos + cDir * ubo.elapsedTime * speedFactor;

    if (nPos.x < 0 || nPos.x >= ubo.spaceWidth || nPos.y < 0 || nPos.y >= ubo.spaceHeight) {
        nPos.x = min(ubo.spaceWidth - 1, max(0, nPos.x));
        nPos.y = min(ubo.spaceHeight - 1, max(0, nPos.y));

        // give a new direction
        uint random = hash(ubo.spaceWidth * uint(cPos.y) + uint(nPos.x) + hash(index + uint(ubo.time) * 1994));
        agents[index].direction = vec2(cos(scaleToRange01(random) * 2 * PI), sin(scaleToRange01(random) * 2 * PI));
    }
    agents[index].pos = nPos;

    imageStore(image, ivec2(agents[index].pos), vec4(1.0));
}